import '../services/api_service.dart';
import '../services/cache_service.dart';
import '../services/sync_service.dart';
import '../utils/api_response.dart';
import '../models/base_model.dart';

/// Base Repository - Works with Freezed models
/// T must have toJson() and fromJson() (generated by Freezed)
abstract class BaseRepository<T extends BaseModel> {
  final ApiService apiService;
  final CacheService cacheService;
  final SyncService syncService;
  final String baseEndpoint;

  BaseRepository({
    required this.apiService,
    required this.cacheService,
    required this.syncService,
    required this.baseEndpoint,
  });

  /// Parse JSON to model (use Freezed's fromJson)
  T fromJson(Map<String, dynamic> json);

  /// Get all
  Future<ApiResponse<List<T>>> getAll({bool useCache = true}) async {
    final cacheKey = '${baseEndpoint}_all';
    
    // Try cache first
    if (useCache) {
      final cached = cacheService.get<List<dynamic>>(
        cacheKey,
        (data) => (data as List)
            .map((e) => fromJson(e as Map<String, dynamic>))
            .toList(),
      );
      if (cached != null && cached.isNotEmpty) {
        return ApiResponse.success(cached.cast<T>());
      }
    }

    // Fetch from API
    final response = await apiService.get<List<dynamic>>(
      baseEndpoint,
      fromJson: (data) => (data as List)
          .map((e) => fromJson(e as Map<String, dynamic>))
          .toList(),
    );

    if (response.success && response.data != null) {
      final items = response.data! as List<T>;
      if (useCache) {
        await cacheService.save(
          cacheKey,
          items.map((item) => item.toJson()).toList(),
        );
      }
      return ApiResponse.success(items);
    }
    return ApiResponse.error(response.message ?? 'Failed to fetch');
  }

  /// Get by ID
  Future<ApiResponse<T>> getById(String id, {bool useCache = true}) async {
    final cacheKey = '${baseEndpoint}_$id';
    
    // Try cache first
    if (useCache) {
      final cached = cacheService.get<Map<String, dynamic>>(
        cacheKey,
        (data) => data as Map<String, dynamic>,
      );
      if (cached != null) {
        return ApiResponse.success(fromJson(cached));
      }
    }

    // Fetch from API
    final response = await apiService.get<Map<String, dynamic>>(
      '$baseEndpoint/$id',
      fromJson: (data) => data as Map<String, dynamic>,
    );

    if (response.success && response.data != null) {
      final item = fromJson(response.data!);
      if (useCache) {
        await cacheService.save(cacheKey, item.toJson());
      }
      return ApiResponse.success(item);
    }
    return ApiResponse.error(response.message ?? 'Failed to fetch');
  }

  /// Create
  Future<ApiResponse<T>> create(T model, {bool syncOffline = true}) async {
    final response = await apiService.post<Map<String, dynamic>>(
      baseEndpoint,
      data: model.toJson(),
      fromJson: (data) => data as Map<String, dynamic>,
    );

    if (response.success && response.data != null) {
      await cacheService.delete('${baseEndpoint}_all');
      return ApiResponse.success(fromJson(response.data!));
    }

    if (syncOffline) {
      await syncService.addToQueue(SyncItem(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        method: 'POST',
        endpoint: baseEndpoint,
        data: model.toJson(),
        timestamp: DateTime.now(),
      ));
    }
    return ApiResponse.error(response.message ?? 'Failed to create');
  }

  /// Update
  Future<ApiResponse<T>> update(String id, T model, {bool syncOffline = true}) async {
    final response = await apiService.put<Map<String, dynamic>>(
      '$baseEndpoint/$id',
      data: model.toJson(),
      fromJson: (data) => data as Map<String, dynamic>,
    );

    if (response.success && response.data != null) {
      final item = fromJson(response.data!);
      await cacheService.save('${baseEndpoint}_$id', item.toJson());
      await cacheService.delete('${baseEndpoint}_all');
      return ApiResponse.success(item);
    }

    if (syncOffline) {
      await syncService.addToQueue(SyncItem(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        method: 'PUT',
        endpoint: '$baseEndpoint/$id',
        data: model.toJson(),
        timestamp: DateTime.now(),
      ));
    }
    return ApiResponse.error(response.message ?? 'Failed to update');
  }

  /// Delete
  Future<ApiResponse<bool>> delete(String id, {bool syncOffline = true}) async {
    final response = await apiService.delete<bool>('$baseEndpoint/$id');

    if (response.success) {
      await cacheService.delete('${baseEndpoint}_$id');
      await cacheService.delete('${baseEndpoint}_all');
      return ApiResponse.success(true);
    }

    if (syncOffline) {
      await syncService.addToQueue(SyncItem(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        method: 'DELETE',
        endpoint: '$baseEndpoint/$id',
        timestamp: DateTime.now(),
      ));
    }
    return ApiResponse.error(response.message ?? 'Failed to delete');
  }
}
