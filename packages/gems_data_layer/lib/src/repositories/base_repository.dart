import '../services/api_service.dart';
import '../services/database_service.dart';
import '../services/sync_service.dart';
import '../utils/api_response.dart';
import '../models/base_model.dart';
import 'dart:convert';

/// Base Repository - Works with Freezed models
/// T must have toJson() and fromJson() (generated by Freezed)
abstract class BaseRepository<T extends BaseModel> {
  final ApiService apiService;
  final DatabaseService databaseService;
  final SyncService syncService;
  final String baseEndpoint;

  BaseRepository({
    required this.apiService,
    required this.databaseService,
    required this.syncService,
    required this.baseEndpoint,
  });

  /// Parse JSON to model (use Freezed's fromJson)
  T fromJson(Map<String, dynamic> json);

  /// Get all
  Future<ApiResponse<List<T>>> getAll({bool useCache = true}) async {
    final cacheKey = '${baseEndpoint}_all';
    
    // Try database first
    if (useCache) {
      final cachedJson = databaseService.get<String>(cacheKey);
      if (cachedJson != null) {
        try {
          final cached = (jsonDecode(cachedJson) as List)
              .map((e) => fromJson(e as Map<String, dynamic>))
              .toList();
          if (cached.isNotEmpty) {
            // Return cached data immediately for fast UI
            // Then try to fetch from API in background
            _fetchAndUpdateCache(cacheKey);
            return ApiResponse.success(cached);
          }
        } catch (e) {
          // Invalid cache, continue to API
        }
      }
    }

    // Fetch from API
    final response = await apiService.get<List<dynamic>>(
      baseEndpoint,
      fromJson: (data) => (data as List)
          .map((e) => fromJson(e as Map<String, dynamic>))
          .toList(),
    );

    if (response.success && response.data != null) {
      final items = response.data! as List<T>;
      if (useCache) {
        await databaseService.save(
          cacheKey,
          jsonEncode(items.map((item) => item.toJson()).toList()),
        );
      }
      return ApiResponse.success(items);
    }

    // If API fails, try to return cached data
    if (useCache) {
      final cachedJson = databaseService.get<String>(cacheKey);
      if (cachedJson != null) {
        try {
          final cached = (jsonDecode(cachedJson) as List)
              .map((e) => fromJson(e as Map<String, dynamic>))
              .toList();
          if (cached.isNotEmpty) {
            return ApiResponse.success(cached);
          }
        } catch (e) {
          // Invalid cache
        }
      }
    }

    return ApiResponse.error(response.message ?? 'Failed to fetch');
  }

  /// Background fetch and update cache
  Future<void> _fetchAndUpdateCache(String cacheKey) async {
    try {
      final response = await apiService.get<List<dynamic>>(
        baseEndpoint,
        fromJson: (data) => (data as List)
            .map((e) => fromJson(e as Map<String, dynamic>))
            .toList(),
      );

      if (response.success && response.data != null) {
        final items = response.data! as List<T>;
        await databaseService.save(
          cacheKey,
          jsonEncode(items.map((item) => item.toJson()).toList()),
        );
      }
    } catch (e) {
      // Silently fail - we already have cached data
    }
  }

  /// Get by ID
  Future<ApiResponse<T>> getById(String id, {bool useCache = true}) async {
    final cacheKey = '${baseEndpoint}_$id';
    
    // Try database first
    if (useCache) {
      final cachedJson = databaseService.get<String>(cacheKey);
      if (cachedJson != null) {
        try {
          final cached = jsonDecode(cachedJson) as Map<String, dynamic>;
          // Return cached data immediately, then try to fetch from API
          _fetchAndUpdateItemCache(cacheKey, id);
          return ApiResponse.success(fromJson(cached));
        } catch (e) {
          // Invalid cache, continue to API
        }
      }
    }

    // Fetch from API
    final response = await apiService.get<Map<String, dynamic>>(
      '$baseEndpoint/$id',
      fromJson: (data) => data as Map<String, dynamic>,
    );

    if (response.success && response.data != null) {
      final item = fromJson(response.data!);
      if (useCache) {
        await databaseService.save(cacheKey, jsonEncode(item.toJson()));
      }
      return ApiResponse.success(item);
    }

    // If API fails, try to return cached data
    if (useCache) {
      final cachedJson = databaseService.get<String>(cacheKey);
      if (cachedJson != null) {
        try {
          final cached = jsonDecode(cachedJson) as Map<String, dynamic>;
          return ApiResponse.success(fromJson(cached));
        } catch (e) {
          // Invalid cache
        }
      }
    }

    return ApiResponse.error(response.message ?? 'Failed to fetch');
  }

  /// Background fetch and update item cache
  Future<void> _fetchAndUpdateItemCache(String cacheKey, String id) async {
    try {
      final response = await apiService.get<Map<String, dynamic>>(
        '$baseEndpoint/$id',
        fromJson: (data) => data as Map<String, dynamic>,
      );

      if (response.success && response.data != null) {
        final item = fromJson(response.data!);
        await databaseService.save(cacheKey, jsonEncode(item.toJson()));
      }
    } catch (e) {
      // Silently fail - we already have cached data
    }
  }

  /// Create
  Future<ApiResponse<T>> create(T model, {bool syncOffline = true}) async {
    // Try API first
    final response = await apiService.post<Map<String, dynamic>>(
      baseEndpoint,
      data: model.toJson(),
      fromJson: (data) => data as Map<String, dynamic>,
    );

    if (response.success && response.data != null) {
      final item = fromJson(response.data!);
      final itemJson = item.toJson();
      final itemId = itemJson['id']?.toString() ?? DateTime.now().millisecondsSinceEpoch.toString();
      // Save to database and invalidate cache
      await databaseService.save('${baseEndpoint}_$itemId', jsonEncode(itemJson));
      await databaseService.delete('${baseEndpoint}_all');
      return ApiResponse.success(item);
    }

    // API failed - save locally for offline support
    if (syncOffline) {
      final modelJson = model.toJson();
      final modelId = modelJson['id']?.toString() ?? DateTime.now().millisecondsSinceEpoch.toString();
      
      // Save to database immediately (optimistic update)
      await databaseService.save('${baseEndpoint}_$modelId', jsonEncode(modelJson));
      await databaseService.delete('${baseEndpoint}_all'); // Invalidate list cache
      
      // Queue for sync when online
      await syncService.addToQueue(SyncItem(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        method: 'POST',
        endpoint: baseEndpoint,
        data: modelJson,
        timestamp: DateTime.now(),
      ));
      
      // Return success with local model (optimistic)
      return ApiResponse.success(model);
    }
    
    return ApiResponse.error(response.message ?? 'Failed to create');
  }

  /// Update
  Future<ApiResponse<T>> update(String id, T model, {bool syncOffline = true}) async {
    // Try API first
    final response = await apiService.put<Map<String, dynamic>>(
      '$baseEndpoint/$id',
      data: model.toJson(),
      fromJson: (data) => data as Map<String, dynamic>,
    );

    if (response.success && response.data != null) {
      final item = fromJson(response.data!);
      await databaseService.save('${baseEndpoint}_$id', jsonEncode(item.toJson()));
      await databaseService.delete('${baseEndpoint}_all');
      return ApiResponse.success(item);
    }

    // API failed - save locally for offline support
    if (syncOffline) {
      // Save to database immediately (optimistic update)
      await databaseService.save('${baseEndpoint}_$id', jsonEncode(model.toJson()));
      await databaseService.delete('${baseEndpoint}_all'); // Invalidate list cache
      
      // Queue for sync when online
      await syncService.addToQueue(SyncItem(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        method: 'PUT',
        endpoint: '$baseEndpoint/$id',
        data: model.toJson(),
        timestamp: DateTime.now(),
      ));
      
      // Return success with local model (optimistic)
      return ApiResponse.success(model);
    }
    
    return ApiResponse.error(response.message ?? 'Failed to update');
  }

  /// Delete
  Future<ApiResponse<bool>> delete(String id, {bool syncOffline = true}) async {
    // Try API first
    final response = await apiService.delete<bool>('$baseEndpoint/$id');

    if (response.success) {
      await databaseService.delete('${baseEndpoint}_$id');
      await databaseService.delete('${baseEndpoint}_all');
      return ApiResponse.success(true);
    }

    // API failed - delete locally for offline support
    if (syncOffline) {
      // Delete from database immediately (optimistic update)
      await databaseService.delete('${baseEndpoint}_$id');
      await databaseService.delete('${baseEndpoint}_all'); // Invalidate list cache
      
      // Queue for sync when online
      await syncService.addToQueue(SyncItem(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        method: 'DELETE',
        endpoint: '$baseEndpoint/$id',
        timestamp: DateTime.now(),
      ));
      
      // Return success (optimistic)
      return ApiResponse.success(true);
    }
    
    return ApiResponse.error(response.message ?? 'Failed to delete');
  }
}
